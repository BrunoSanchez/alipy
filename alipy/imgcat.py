import star
import pysex
import quad
import os
import numpy as np
import scipy.ndimage
import pyfits


class ImgCat:
	"""
	Represent an individual image and its associated catalog, starlist, quads etc.
	"""

	def __init__(self, file, cat=None):
		"""
		
		:param file: Path to the FITS file, or alternatively just a string to identify the image.
		:type file: string
		
		:param cat: Catalog generated by SExtractor (if available -- if not, we'll make our own)
		:type cat: asciidata catalog
		
		"""
		self.file = file
		
		(imgdir, filename) = os.path.split(file)
		(common, ext) = os.path.splitext(filename)
		self.basepath = os.path.join("alipy_out", common)
		if not os.path.isdir("alipy_out"):
			os.makedirs("alipy_out")
		
		self.cat = cat
		self.starlist = []
		self.quadlist = []
		self.transform = star.SimpleTransform()
		
		self.xlim = (0, 0)
		self.ylim = (0, 0)
	
	def __str__(self):
		return "%20s: approx %4i x %4i, %4i stars, %4i quads" % (os.path.basename(self.file),
			self.xlim[1] - self.xlim[0], self.ylim[1] - self.ylim[0],
			len(self.starlist), len(self.quadlist))
	
	def makecat(self, rerun=False):
		self.cat = pysex.run(self.file, conf_args={'DETECT_THRESH':3.0, 'ANALYSIS_THRESH':3.0, 'DETECT_MINAREA':10,
		'PIXEL_SCALE':1.0, 'SEEING_FWHM':2.0, "FILTER":"Y"},
		params=['X_IMAGE', 'Y_IMAGE', 'FLUX_AUTO', 'FWHM_IMAGE', 'FLAGS', 'ELONGATION', 'NUMBER'],
		keepcat=True, rerun=rerun, catdir="alipy_cats")

	
	def makestarlist(self, n=300):
		if self.cat:
			self.starlist = star.sortstarlistbyflux(star.readsexcat(self.cat, verbose=True))[:n]
			(xmin, xmax, ymin, ymax) = star.area(self.starlist, border=0.01)
			self.xlim = (xmin, xmax)
			self.ylim = (ymin, ymax)
		else:
			raise RuntimeError("No cat : call makecat first !")
	
	
	def makequadlist(self, add=True, **kwargs):
		"""
		:param add: If True, I add the new quads to the existing ones.
		:type add: boolean
		"""
		if not add:
			self.quadlist = []
		self.quadlist.extend(quad.makequads1(self.starlist, n=7))
		#self.quadlist.extend(quad.makequads2(self.starlist, f=3, n=5))
		self.quadlist.extend(quad.makequads2(self.starlist, f=6, n=5))
		
		self.quadlist = quad.removeduplicates(self.quadlist)
		
	
	def showstars(self):
		"""
		Uses f2n to write a png image with circled stars.
		"""
		try:
			import f2n
		except ImportError:
			print "Couldn't import f2n -- install it !"
			return
		
		myimage = f2n.fromfits(self.file, verbose=False)
		myimage.rebin(int(myimage.xb/1000.0))
		myimage.setzscale("auto", "auto")
		myimage.makepilimage("log", negative = False)
		#myimage.upsample()
		myimage.drawstarlist(self.starlist, r=8)
		myimage.writetitle(os.path.basename(self.file))
		#myimage.writeinfo(["This is a demo", "of some possibilities", "of f2n.py"], colour=(255,100,0))
		myimage.tonet(self.basepath + "_stars.png")

	
	
	def showquads(self, show=False, flux=True):
		"""
		Uses matplotlib to write/show the quads.
		"""
		import matplotlib.pyplot as plt
		#import matplotlib.patches
		#import matplotlib.collections
		
		plt.figure(figsize=(10, 10))
		
		a = star.listtoarray(self.starlist, full=True)
		if flux:
			f = np.log10(a[:,2])
			fmax = np.max(f)
			fmin = np.min(f)
			f = 1.0 + 8.0 * (f-fmin)/(fmax-fmin)
			plt.scatter(a[:,0], a[:,1], s=f, color="black")
		else:
			plt.plot(a[:,0], a[:,1], marker=",", ls="none", color="black")
		
		for quad in self.quadlist:
			polycorners = star.listtoarray(quad.stars)
			polycorners = ccworder(polycorners)
			plt.fill(polycorners[:,0], polycorners[:,1], alpha=0.03, ec="none")
	
		plt.xlim(self.xlim)
		plt.ylim(self.ylim)
		plt.title(str(self))
		plt.xlabel("x")
		plt.ylabel("y")
		
		
		ax = plt.gca()
		ax.set_aspect('equal', 'datalim')
	

		if show:
			plt.show()
		else:
			plt.savefig(self.basepath + "_quads.png")



	def affineremap(self, shape, filepath=None):
		"""
		Apply the simple affine transform to the image and saves the result as FITS.
		If filename is None, image is saved next to original one.
		Uses only scipy.ndimage, no IRAF here.
		
		:param shape: Output shape (width, height) 
		:type shape: tuple
		
		"""
		inv = self.transform.inverse()
		(matrix, offset) = inv.matrixform()
		#print matrix, offset
		
		data, hdr = fromfits(self.file, hdu = 0, verbose = True)
		data = scipy.ndimage.interpolation.affine_transform(data, matrix, offset=offset, output_shape = shape)
		
		if not filepath:
			#(imgdir, filename) = os.path.split(self.file)
			#(common, ext) = os.path.splitext(filename)
			#filepath = os.path.join(imgdir, common + "_affineremap.fits")
			filepath = self.basepath + "_affineremap.fits"
		
		tofits(filepath, data, hdr = None, verbose = True)


def ccworder(a):
	"""
	Sorting a coordinate array CCW to plot polygons ...
	"""
	ac = a - np.mean(a, 0)
	indices = np.argsort(np.arctan2(ac[:, 1], ac[:, 0]))
	return a[indices]


def fromfits(infilename, hdu = 0, verbose = True):
	"""
	Reads a FITS file and returns a 2D numpy array of the data.
	Use hdu to specify which HDU you want (default = primary = 0)
	"""
	
	pixelarray, hdr = pyfits.getdata(infilename, hdu, header=True)
	pixelarray = np.asarray(pixelarray).transpose()
	
	pixelarrayshape = pixelarray.shape
	if verbose :
		print "FITS import shape : (%i, %i)" % (pixelarrayshape[0], pixelarrayshape[1])
		print "FITS file BITPIX : %s" % (hdr["BITPIX"])
		print "Internal array type :", pixelarray.dtype.name
	
	return pixelarray, hdr

def tofits(outfilename, pixelarray, hdr = None, verbose = True):
	"""
	Takes a 2D numpy array and write it into a FITS file.
	If you specify a header (pyfits format, as returned by fromfits()) it will be used for the image.
	You can give me boolean numpy arrays, I will convert them into 8 bit integers.
	"""
	pixelarrayshape = pixelarray.shape
	if verbose :
		print "FITS export shape : (%i, %i)" % (pixelarrayshape[0], pixelarrayshape[1])

	if pixelarray.dtype.name == "bool":
		pixelarray = np.cast["uint8"](pixelarray)

	if os.path.isfile(outfilename):
		os.remove(outfilename)
	
	if hdr == None: # then a minimal header will be created 
		hdu = pyfits.PrimaryHDU(pixelarray.transpose())
	else: # this if else is probably not needed but anyway ...
		hdu = pyfits.PrimaryHDU(pixelarray.transpose(), hdr)

	hdu.writeto(outfilename)
	
	if verbose :
		print "Wrote %s" % outfilename

		
