import star
import pysex
import quad
import os
import numpy as np
import scipy.ndimage
import pyfits


class ImgCat:
	"""
	Represent an individual image and its associated catalog, starlist, quads etc.
	"""

	def __init__(self, file, cat=None):
		"""
		
		:param file: Path to the FITS file, or alternatively just a string to identify the image.
		:type file: string
		
		:param cat: Catalog generated by SExtractor (if available -- if not, we'll make our own)
		:type cat: asciidata catalog
		
		"""
		self.file = file
		
		(imgdir, filename) = os.path.split(file)
		(common, ext) = os.path.splitext(filename)
		self.common = common
		
		self.cat = cat
		self.starlist = []
		self.quadlist = []
		self.quadlevel = 0 # encodes what kind of quads have already been computed
		
		self.transform = star.SimpleTransform()
		
		self.xlim = (0, 0)
		self.ylim = (0, 0)
	
	def __str__(self):
		return "%20s: approx %4i x %4i, %4i stars, %4i quads, quadlevel %i" % (os.path.basename(self.file),
			self.xlim[1] - self.xlim[0], self.ylim[1] - self.ylim[0],
			len(self.starlist), len(self.quadlist), self.quadlevel)
	
	def makecat(self, rerun=False, verbose=True):
		self.cat = pysex.run(self.file, conf_args={'DETECT_THRESH':3.0, 'ANALYSIS_THRESH':3.0, 'DETECT_MINAREA':10,
		'PIXEL_SCALE':1.0, 'SEEING_FWHM':2.0, "FILTER":"Y"},
		params=['X_IMAGE', 'Y_IMAGE', 'FLUX_AUTO', 'FWHM_IMAGE', 'FLAGS', 'ELONGATION', 'NUMBER'],
		keepcat=True, rerun=rerun, catdir="alipy_cats")

	
	def makestarlist(self, skipsaturated=False, n=500, verbose=True):
		if self.cat:
			if skipsaturated:
				maxflag = 3
			else:
				maxflag = 7
			self.starlist = star.sortstarlistbyflux(star.readsexcat(self.cat, maxflag=maxflag, verbose=verbose))[:n]
			(xmin, xmax, ymin, ymax) = star.area(self.starlist, border=0.01)
			self.xlim = (xmin, xmax)
			self.ylim = (ymin, ymax)
		else:
			raise RuntimeError("No cat : call makecat first !")
	
	
	def makemorequads(self, verbose=True):
		"""
		We add more quads, following the quadlevel.
		"""
		#if not add:
		#	self.quadlist = []
		if self.quadlevel == 0:
			self.quadlist.extend(quad.makequads1(self.starlist, n=7, verbose=verbose))
		elif self.quadlevel == 1:
			self.quadlist.extend(quad.makequads2(self.starlist, f=3, n=5, verbose=verbose))
		elif self.quadlevel == 2:
			self.quadlist.extend(quad.makequads2(self.starlist, f=6, n=5, verbose=verbose))
		else:
			return False
		
		self.quadlist = quad.removeduplicates(self.quadlist, verbose=verbose)
		self.quadlevel += 1
		return True	
		
	
	def showstars(self, verbose=True):
		"""
		Uses f2n to write a png image with circled stars.
		"""
		try:
			import f2n
		except ImportError:
			print "Couldn't import f2n -- install it !"
			return
		
		if verbose:
			print "Writing png ..."
		myimage = f2n.fromfits(self.file, verbose=False)
		#myimage.rebin(int(myimage.xb/1000.0))
		myimage.setzscale("auto", "auto")
		myimage.makepilimage("log", negative = False)
		#myimage.upsample()
		myimage.drawstarlist(self.starlist, r=8, autocolour="flux")
		myimage.writetitle(os.path.basename(self.file))
		#myimage.writeinfo(["This is a demo", "of some possibilities", "of f2n.py"], colour=(255,100,0))
		if not os.path.isdir("alipy_visu"):
				os.makedirs("alipy_visu")
		myimage.tonet(os.path.join("alipy_visu", self.common + "_stars.png"))

	
	
	def showquads(self, show=False, flux=True, verbose=True):
		"""
		Uses matplotlib to write/show the quads.
		"""
		if verbose:
			print "Plotting quads ..."
		
		import matplotlib.pyplot as plt
		#import matplotlib.patches
		#import matplotlib.collections
		
		plt.figure(figsize=(10, 10))
		
		a = star.listtoarray(self.starlist, full=True)
		if flux:
			f = np.log10(a[:,2])
			fmax = np.max(f)
			fmin = np.min(f)
			f = 1.0 + 8.0 * (f-fmin)/(fmax-fmin)
			plt.scatter(a[:,0], a[:,1], s=f, color="black")
		else:
			plt.plot(a[:,0], a[:,1], marker=",", ls="none", color="black")
		
		for quad in self.quadlist:
			polycorners = star.listtoarray(quad.stars)
			polycorners = ccworder(polycorners)
			plt.fill(polycorners[:,0], polycorners[:,1], alpha=0.03, ec="none")
	
		plt.xlim(self.xlim)
		plt.ylim(self.ylim)
		plt.title(str(self))
		plt.xlabel("x")
		plt.ylabel("y")
		ax = plt.gca()
		ax.set_aspect('equal', 'datalim')
	
		if show:
			plt.show()
		else:
			if not os.path.isdir("alipy_visu"):
				os.makedirs("alipy_visu")
			plt.savefig(os.path.join("alipy_visu", self.common + "_quads.png"))



	def affineremap(self, shape, filepath=None, makepng=False, verbose=True):
		"""
		Apply the simple affine transform to the image and saves the result as FITS.
		If filename is None, image is saved next to original one.
		Uses only scipy.ndimage, no IRAF here.
		
		:param shape: Output shape (width, height) 
		:type shape: tuple
		
		"""
		inv = self.transform.inverse()
		(matrix, offset) = inv.matrixform()
		#print matrix, offset
		
		data, hdr = fromfits(self.file, hdu = 0, verbose = verbose)
		data = scipy.ndimage.interpolation.affine_transform(data, matrix, offset=offset, output_shape = shape)
		
		if not filepath:
			#(imgdir, filename) = os.path.split(self.file)
			#(common, ext) = os.path.splitext(filename)
			#filepath = os.path.join(imgdir, common + "_affineremap.fits")
			if not os.path.isdir("alipy_out"):
				os.makedirs("alipy_out")
			filepath = os.path.join("alipy_out", self.common + "_affineremap.fits")
		
		tofits(filepath, data, hdr = None, verbose = verbose)
		
		if makepng:
			try:
				import f2n
			except ImportError:
				print "Couldn't import f2n -- install it !"
				return
			myimage = f2n.f2nimage(numpyarray=data, verbose=verbose)
			myimage.setzscale("auto", "auto")
			myimage.makepilimage("log", negative = False)
			myimage.writetitle(self.common + "_affineremap.fits")
			if not os.path.isdir("alipy_out"):
					os.makedirs("alipy_out")
			myimage.tonet(os.path.join("alipy_out", self.common + "_affineremap.png"))


def ccworder(a):
	"""
	Sorting a coordinate array CCW to plot polygons ...
	"""
	ac = a - np.mean(a, 0)
	indices = np.argsort(np.arctan2(ac[:, 1], ac[:, 0]))
	return a[indices]


def fromfits(infilename, hdu = 0, verbose = True):
	"""
	Reads a FITS file and returns a 2D numpy array of the data.
	Use hdu to specify which HDU you want (default = primary = 0)
	"""
	
	if verbose:
		print "Reading %s ..." % (os.path.basename(infilename))
	
	pixelarray, hdr = pyfits.getdata(infilename, hdu, header=True)
	pixelarray = np.asarray(pixelarray).transpose()
	
	pixelarrayshape = pixelarray.shape
	if verbose :
		print "FITS import (%i, %i) BITPIX %s / %s" % (pixelarrayshape[0], pixelarrayshape[1], hdr["BITPIX"], str(pixelarray.dtype.name))
		
	return pixelarray, hdr

def tofits(outfilename, pixelarray, hdr = None, verbose = True):
	"""
	Takes a 2D numpy array and write it into a FITS file.
	If you specify a header (pyfits format, as returned by fromfits()) it will be used for the image.
	You can give me boolean numpy arrays, I will convert them into 8 bit integers.
	"""
	pixelarrayshape = pixelarray.shape
	if verbose :
		print "FITS export (%i, %i) %s ..." % (pixelarrayshape[0], pixelarrayshape[1], str(pixelarray.dtype.name))

	if pixelarray.dtype.name == "bool":
		pixelarray = np.cast["uint8"](pixelarray)

	if os.path.isfile(outfilename):
		os.remove(outfilename)
	
	if hdr == None: # then a minimal header will be created 
		hdu = pyfits.PrimaryHDU(pixelarray.transpose())
	else: # this if else is probably not needed but anyway ...
		hdu = pyfits.PrimaryHDU(pixelarray.transpose(), hdr)

	hdu.writeto(outfilename)
	
	if verbose :
		print "Wrote %s" % outfilename

		
